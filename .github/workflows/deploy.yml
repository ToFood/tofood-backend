name: Deploy üåê

on:
  push:
    branches:
      - main
      - develop

env:
  AWS_REGION: ${{ vars.AWS_REGION }}
  AWS_ACCESS_KEY_ID: ${{ vars.AWS_ACCESS_KEY_ID }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}
  AWS_ACCOUNT_ID: ${{ vars.AWS_ACCOUNT_ID }}
  IMAGE_NAME: "tofood/backend"
  CLUSTER_NAME: "tofood-eks-cluster"
  DEPLOYMENT_NAME: "tofood-deployment"
  NODEGROUP_NAME: "tofood-nodegroup"

jobs:
  # Job de Build do Projeto Node/TypeScript
  build_project:
    name: üõ†Ô∏è Build do Projeto
    runs-on: ubuntu-latest

    steps:
      - name: üé® Checkout do reposit√≥rio
        uses: actions/checkout@v4

      - name: üì¶ Instalar depend√™ncias
        run: |
          npm install

      - name: üõ†Ô∏è Build do projeto
        run: |
          npm run build

  # Job de Lint
  lint:
    name: üé® Lint - Valida√ß√£o do C√≥digo
    runs-on: ubuntu-latest
    needs: build_project # Roda ap√≥s o sucesso do build_project

    steps:
      - name: üé® Checkout do reposit√≥rio
        uses: actions/checkout@v4

      - name: üì¶ Instalar depend√™ncias
        run: |
          npm install

      - name: üîç Rodar Lint
        run: |
          npm run lint

  # Job de Teste
  test:
    name: üß™ Testes da Aplica√ß√£o
    runs-on: ubuntu-latest
    needs: build_project # Roda ap√≥s o sucesso do build_project

    steps:
      - name: üé® Checkout do reposit√≥rio
        uses: actions/checkout@v4

      - name: üì¶ Instalar depend√™ncias
        run: |
          npm install

      - name: üß™ Executar Testes
        run: |
          npm test

  # Job de Configura√ß√£o Inicial
  setup:
    name: üõú Estabelecendo conex√£o com AWS
    runs-on: ubuntu-latest
    needs: [lint, test] # Roda ap√≥s o sucesso dos jobs de lint e test

    steps:
      - name: üé® Checkout do reposit√≥rio
        uses: actions/checkout@v4

      - name: üîê Configurar credenciais da AWS
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ env.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

  # Job de Infraestrutura EKS
  eks_infrastructure:
    name: üèóÔ∏è Provisionando EKS
    runs-on: ubuntu-latest
    needs: setup

    steps:
      - name: üîë Verificar e aplicar pol√≠tica de permiss√£o
        run: |
          POLICY_ARN="arn:aws:iam::${AWS_ACCOUNT_ID}:policy/CustomPutRolePolicyPermission"
          if ! aws iam get-policy --policy-arn $POLICY_ARN 2>/dev/null; then
            echo "Criando pol√≠tica personalizada para iam:PutRolePolicy..."
            aws iam create-policy \
              --policy-name CustomPutRolePolicyPermission \
              --policy-document '{
                "Version": "2012-10-17",
                "Statement": [
                  {
                    "Effect": "Allow",
                    "Action": "iam:PutRolePolicy",
                    "Resource": "*"
                  }
                ]
              }'
          fi
          echo "Anexando a pol√≠tica √† role de execu√ß√£o..."
          aws iam attach-role-policy \
            --role-name GitHubActionsRole \
            --policy-arn $POLICY_ARN

      - name: üõ†Ô∏è Criar cluster EKS (se n√£o existir)
        run: |
          if ! aws eks describe-cluster --name $CLUSTER_NAME --region $AWS_REGION; then
            echo "Cluster n√£o encontrado. Criando cluster EKS..."
            aws eks create-cluster \
              --name $CLUSTER_NAME \
              --region $AWS_REGION \
              --kubernetes-version "1.21" \
              --role-arn arn:aws:iam::${AWS_ACCOUNT_ID}:role/EKSClusterRole \
              --resources-vpc-config subnetIds=subnet-xxxxxx,subnet-yyyyyy,securityGroupIds=sg-zzzzzz
            aws eks wait cluster-active --name $CLUSTER_NAME --region $AWS_REGION
          else
            echo "Cluster EKS j√° existe."
          fi

      - name: üõ†Ô∏è Criar NodeGroup (se n√£o existir)
        run: |
          if ! aws eks describe-nodegroup --cluster-name $CLUSTER_NAME --nodegroup-name $NODEGROUP_NAME --region $AWS_REGION; then
            echo "NodeGroup n√£o encontrado. Criando NodeGroup..."
            aws eks create-nodegroup \
              --cluster-name $CLUSTER_NAME \
              --nodegroup-name $NODEGROUP_NAME \
              --node-role arn:aws:iam::${AWS_ACCOUNT_ID}:role/EKSNodeRole \
              --subnets subnet-xxxxxx subnet-yyyyyy \
              --scaling-config minSize=1,maxSize=3,desiredSize=2 \
              --instance-types t3.medium \
              --region $AWS_REGION
            aws eks wait nodegroup-active --cluster-name $CLUSTER_NAME --nodegroup-name $NODEGROUP_NAME --region $AWS_REGION
          else
            echo "NodeGroup j√° existe."
          fi

  # Job de Configura√ß√£o do ECR
  ecr_setup:
    name: ü§ñ Provisionando ECR
    runs-on: ubuntu-latest
    needs: setup # Roda ap√≥s o sucesso do setup

    steps:
      - name: üõ†Ô∏è Criar reposit√≥rio ECR (se n√£o existir)
        run: |
          aws ecr describe-repositories --repository-names "$IMAGE_NAME" --region $AWS_REGION || \
          aws ecr create-repository --repository-name "$IMAGE_NAME" --region $AWS_REGION

      - name: Login no Amazon ECR
        run: |
          aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com

  # Job de Build e Push da Imagem Docker
  docker_build_push:
    name: üêã Docker - Build & Push
    runs-on: ubuntu-latest
    needs: [ecr_setup, eks_infrastructure]

    steps:
      - name: üõ†Ô∏è Build da imagem Docker
        run: |
          docker build -t $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$IMAGE_NAME:latest .

      - name: üè∑Ô∏è Tag da imagem
        run: |
          docker tag $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$IMAGE_NAME:latest $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$IMAGE_NAME:${{ github.sha }}

      - name: üì§ Push da imagem Docker
        run: |
          docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$IMAGE_NAME:latest
          docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$IMAGE_NAME:${{ github.sha }}

  # Job de Deploy no EKS
  eks_deploy:
    name: üöÄ Deploy
    runs-on: ubuntu-latest
    needs: [eks_infrastructure, docker_build_push]

    steps:
      - name: ‚öôÔ∏è Configurar kubectl
        run: |
          aws eks update-kubeconfig --region $AWS_REGION --name $CLUSTER_NAME

      - name: üöÄ Atualizar deployment no EKS
        id: deploy
        run: |
          set -e
          kubectl set image deployment/$DEPLOYMENT_NAME tofood-container=$AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$IMAGE_NAME:latest || echo "rollback_needed=true" >> $GITHUB_ENV
          kubectl rollout status deployment/$DEPLOYMENT_NAME || echo "rollback_needed=true" >> $GITHUB_ENV

      - name: ‚ö†Ô∏è Rollback do deployment
        if: env.rollback_needed == 'true'
        run: |
          echo "Ocorreu algum erro ao tentar realizar o deploy na AWS, Restaurando a vers√£o anterior da imagem..."
          kubectl rollout undo deployment/$DEPLOYMENT_NAME

      - name: ‚úÖ Deployado
        if: env.rollback_needed != 'true'
        run: |
          echo "Deploy bem-sucedido!"
          # Obt√©m o hostname ou IP do LoadBalancer associado ao servi√ßo
          SERVICE_URL=$(kubectl get svc $DEPLOYMENT_NAME -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          echo "URL de Produ√ß√£o: http://$SERVICE_URL"
          echo "Outras Informa√ß√µes Importantes:"
          kubectl get svc $DEPLOYMENT_NAME -o wide
          kubectl get nodes
