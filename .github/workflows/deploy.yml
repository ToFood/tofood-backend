name: Deploy üåê

on:
  push:
    branches:
      - main # S√≥ ativa em pushes na branch `main`

jobs:
  deploy-applications:
    runs-on: ubuntu-latest

    env:
      AWS_REGION: ${{ vars.AWS_REGION }}
      AWS_ACCESS_KEY_ID: ${{ vars.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }} # Inclu√≠do o token de sess√£o
      AWS_ACCOUNT_ID: ${{ vars.AWS_ACCOUNT_ID }}
      IMAGE_NAME: "tofood/backend"
      CLUSTER_NAME: "tofood-eks-cluster"
      DEPLOYMENT_NAME: "tofood-deployment" # Nome do seu Deployment no EKS
      NODEGROUP_NAME: "tofood-nodegroup" # Nome do NodeGroup

    steps:
      # Fazer checkout do c√≥digo-fonte
      - name: üé® Fazer checkout do reposit√≥rio
        uses: actions/checkout@v4

      # Configurar as credenciais da AWS
      - name: üîê Configurar credenciais da AWS
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ vars.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }} # Passar o token de sess√£o
          aws-region: ${{ vars.AWS_REGION }}

      # Verificar e aplicar pol√≠tica de permiss√£o se necess√°rio
      - name: üîë Verificar e aplicar pol√≠tica de permiss√£o
        run: |
          POLICY_ARN="arn:aws:iam::${AWS_ACCOUNT_ID}:policy/CustomPutRolePolicyPermission"
          if ! aws iam get-policy --policy-arn $POLICY_ARN 2>/dev/null; then
            echo "Criando pol√≠tica personalizada para iam:PutRolePolicy..."
            aws iam create-policy \
              --policy-name CustomPutRolePolicyPermission \
              --policy-document '{
                "Version": "2012-10-17",
                "Statement": [
                  {
                    "Effect": "Allow",
                    "Action": "iam:PutRolePolicy",
                    "Resource": "*"
                  }
                ]
              }'
          fi
          echo "Anexando a pol√≠tica √† role de execu√ß√£o..."
          aws iam attach-role-policy \
            --role-name GitHubActionsRole \
            --policy-arn $POLICY_ARN

      # Criar cluster EKS se n√£o existir
      - name: üõ†Ô∏è Criar cluster EKS (se n√£o existir)
        run: |
          if ! aws eks describe-cluster --name $CLUSTER_NAME --region $AWS_REGION; then
            echo "Cluster n√£o encontrado. Criando cluster EKS..."
            aws eks create-cluster \
              --name $CLUSTER_NAME \
              --region $AWS_REGION \
              --kubernetes-version "1.21" \
              --role-arn arn:aws:iam::${AWS_ACCOUNT_ID}:role/EKSClusterRole \
              --resources-vpc-config subnetIds=subnet-xxxxxx,subnet-yyyyyy,securityGroupIds=sg-zzzzzz
            echo "Cluster EKS criado. Aguardando a finaliza√ß√£o da cria√ß√£o..."
            aws eks wait cluster-active --name $CLUSTER_NAME --region $AWS_REGION
          else
            echo "Cluster EKS j√° existe."
          fi

      # Criar NodeGroup se n√£o existir
      - name: üõ†Ô∏è Criar NodeGroup (se n√£o existir)
        run: |
          if ! aws eks describe-nodegroup --cluster-name $CLUSTER_NAME --nodegroup-name $NODEGROUP_NAME --region $AWS_REGION; then
            echo "NodeGroup n√£o encontrado. Criando NodeGroup..."
            aws eks create-nodegroup \
              --cluster-name $CLUSTER_NAME \
              --nodegroup-name $NODEGROUP_NAME \
              --node-role arn:aws:iam::${AWS_ACCOUNT_ID}:role/EKSNodeRole \
              --subnets subnet-xxxxxx subnet-yyyyyy \
              --scaling-config minSize=1,maxSize=3,desiredSize=2 \
              --instance-types t3.medium \
              --region $AWS_REGION;
            echo "NodeGroup criado. Aguardando a finaliza√ß√£o da cria√ß√£o..."
            aws eks wait nodegroup-active --cluster-name $CLUSTER_NAME --nodegroup-name $NODEGROUP_NAME --region $AWS_REGION
          else
            echo "NodeGroup j√° existe.";
          fi

      # Adicionar etapa de cria√ß√£o do reposit√≥rio no ECR
      - name: üõ†Ô∏è Criar reposit√≥rio ECR (se n√£o existir)
        run: |
          aws ecr describe-repositories --repository-names "tofood/backend" --region $AWS_REGION || \
          aws ecr create-repository --repository-name "tofood/backend" --region $AWS_REGION

      # Login no Amazon ECR
      - name: üêã Login no Amazon ECR
        run: |
          aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com

      # Build da imagem Docker
      - name: üõ†Ô∏è Build da imagem Docker
        run: |
          docker build -t $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$IMAGE_NAME:latest .

      # Tag da imagem com o SHA do commit
      - name: üè∑Ô∏è Tag da imagem
        run: |
          docker tag $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$IMAGE_NAME:latest $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$IMAGE_NAME:${{ github.sha }}

      # Push da imagem para o Amazon ECR
      - name: üì§ Push da imagem Docker
        run: |
          docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$IMAGE_NAME:latest
          docker push $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$IMAGE_NAME:${{ github.sha }}

      # Configurar o kubectl
      - name: ‚öôÔ∏è Configurar kubectl
        run: |
          aws eks update-kubeconfig --region $AWS_REGION --name $CLUSTER_NAME

      # Atualizar o Deployment no Kubernetes (EKS)
      - name: üöÄ Atualizar deployment no EKS
        run: |
          kubectl set image deployment/$DEPLOYMENT_NAME tech-challenge-container=$AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com/$IMAGE_NAME:latest
          kubectl rollout status deployment/$DEPLOYMENT_NAME

      # Mostrar as inst√¢ncias no cluster
      - name: üñ•Ô∏è Mostrar as inst√¢ncias do cluster
        run: |
          kubectl get nodes
